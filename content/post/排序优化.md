+++
title="（九）排序优化"
date=2020-03-23T11:28:47+08:00
categories=["数据结构与算法"]
toc=false
+++

### 如何优化快速排序
我们先来看下，为什么最坏情况下快速排序的时间复杂度是O(n²)呢？如果数据原来就算有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为O(n²)。实际上，**这种O(n²)时间复杂度出现的主要原因还是因为我们分区选的不够合理**。

那么什么样的分区点是好的分区点呢？或者说如何来选择分区点呢？

最理想的分区点是：**被分区点分开的两个分区中，数据的数量差不多**。

这里介绍两个比较常用、比较简单的分区算法：

1. **三数取中法**
   我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。Go语言采用的就是“三数取中”法。

2. **随机法**
  随机法就算每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选择的很差的情况，这样选的分区点是比较好的。时间复杂度退化为最糟糕的O(n²)的情况，出现的可能性不大。

### 举例分析排序函数
我们来看一下Go语言中的排序算法。
![](https://pic.downk.cc/item/5e7858fe5c560911297e4d2a.png)
在元素的个数小于等于12的时候，quickSort就会退化为希尔排序（插入排序的优化版），不再继续用递归来做快速排序。

当maxDepth等于0的时候就采用堆排序。

