+++
title="（六）递归"
date=2020-03-19T09:49:50+08:00
categories=["数据结构与算法"]
toc=false
+++

### 如何理解“递归”
递归是一种应用非常广泛的算法（或者编程技巧）。有很多数据结构和算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等等。所以，搞懂递归非常重要。我们通常把递归求解进行分解，去的过程叫“递”，回来的过程叫“归”。基本上所有的递归问题都可以用递推公式来表示。

### 递归需要满足的三个条件
1. **一个问题的解可以分解为几个子问题的解**
什么叫做子问题？子问题就是数据规模更小的问题。

2. **这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样**
3. **存在递归终止条件**

### 如何编写递归代码
写递归代码最关键的是**写出递推公式，找到终止条件**。这里举一个例子，假如这里有n个台阶，每次你可以跨1个台阶或者2个台阶，请问走这n个台阶有多少种走法？

仔细想一下，实际上可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1阶后，n-1台阶的走法加上先走2阶后，n-2个台阶的走法。用递推公式表示就是：
```shell script
f(n) = f(n-1) + f(n-2)
```
有了递推公式，递归代码基本就完成了一半。我们再来看一下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以f(1)=1。这个递归条件足够吗？我们可以试一下。当n=2时，f(n)=f(1)+f(0)。这个时候f(2)就无法求解了。当然可以把f(0)也设置为1。但是这样就不符合逻辑了，所以f(2)=2。我们把终止条件和递推公式放在一起就是这样：
```go
func f(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }
    return f(n-1)+f(n-2)
}
```
对于递归代码，我们不要去想试图理解整个递和归的过程，因为这样很容易被绕进去。因此，**编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤**

### 递归要警惕堆栈溢出
我们以前学栈的时候，说过函数调用栈。每调用一个函数，都会将临时遍历封装为栈帧压入内存栈，等函数执行完成返回时才出栈。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

为此，我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。当递归调用超过一定深度的时候（比如100）之后，我们就不继续往下再递归了，直接返回报错。
```go
var depth = 0

func f(n int) (int,error) {
    depth++
    if depth > 100 {
        return 0,errors.New("超过最大调用深度")
    }
    return f(n-1)+1,nil
}
```
但这种做法并不能完全解决问题，因为最大允许的递归深度和当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如10，5就可以用这种方法，否则这种方法并不是很实用。

### 递归代码要警惕重复计算
我们把刚刚的台阶问题的递归过程图解一下的话，是这样的：
![](https://external-30160.picsz.qpic.cn/e7e778994e90265344f6ac9da39e01bf)
从图中，我们可以直观的看到，想要计算f(5)，需要先计算f(4)和f(3)，而计算f(4)还需要计算f(3)，因此，f(3)就被计算很多次，这就是重复计算问题。

为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的f(k)。当递归调用到f(k)时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚刚讲的问题了。
```go
var m = make(map[int]int,n)
func f(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }
    if v,ok := m[n];ok {
        return v
    }
    
    ret := f(n-1) + f(n-2)
    m[n] = ret
    return ret
}
```
在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个客观的时间成本。在空间复杂度上，因为递归调用溢出就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如f(n)=f(n-1)+1这个递归代码，空间复杂度并不是O(1)，而是O(n)。

### 将递归代码改写为非递归代码
```go
func f(n int) int {
    ret := 1
    for i:=2;i<=n;i++ {
        ret += 1
    }
    return ret
}
```
```go
func f(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }
    ret := 0
    pre := 2
    prepre := 1
    for i=3;i<=n;i++ {
        ret = pre + prepre
        // 向后推进
        prepre = pre
        pre = ret
    }
    return ret
}
```
笼统的讲，所有的递归代码都可以改为这种**迭代循环**的非递归写法。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。

但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面所说的问题，反而徒增了实现的复杂度。
