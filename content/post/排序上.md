+++
title="（七）排序（上）"
date=2020-03-20T15:53:55+08:00
categories=["数据结构与算法"]
toc=false
+++

### 总览
![](https://external-30160.picsz.qpic.cn/fdfa079892e639111f3cf65f75370c31)

插入排序和冒泡排序的时间复杂度相同，都是O(n²)，但是在时间的软件开发里，为什么我们更倾向于使用插入排序而不是冒泡排序呢？

### 如何分析一个“排序算法”
学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是学会如何评价、分析一个排序算法。那分析一个排序算法，要从哪几个方面入手呢？

#### 1.排序算法的执行效率
1. 最好、最坏、平均时间复杂度
为什么要区分这三种时间复杂度呢？
    1. 有些排序算法会区分，为了好对比，所以我们最好都做一下区分
    2. 对于排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现
<br/>
2. 时间复杂度的系数、常数、低阶
我们知道，时间复杂度反应的是数据规模n很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是时间的软件开发中，我们排序的可能是10个、100个、1000个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。
<br/>
3. 比较次数和交换（或移动）次数
基于比较的排序算法的执行过程，会涉及两种操作一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

#### 2.排序算法的内存消耗
前面说过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念。**原地排序（Stored in place）**。原地排序算法，就是特指空间复杂度是O(1)的排序算法。冒泡、选择和插入都是原地排序。

#### 3.排序算法的稳定性
仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还要一个重要的度量指标，**稳定性**。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

### 冒泡排序（Bubble Sort）
冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它两互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。
```go
func bubbleSort(a []int) []int {
    if len(a) <= 1 {
        return a
    }
    flag := false
    for i:=0;i<len(a);i++ {
        for j:=0;j<len(a)-i-1;j++ {
            if a[j] > a[j+1] {
                a[j],a[j+1] = a[j+1],a[j]
                flag = true
            }
        }
        // 没有数据交换，提前退出
        if !flag {
            break
        }
    }
}
```
按照上面的分析方法，我们现在来分析一下冒泡排序。
1. 冒泡排序是原地排序吗？
冒泡的过程只涉及相邻数据的交换，最多只需要常量级的临时空间，所以空间复杂度为O(1)，是一个原地排序算法。

2. 冒泡排序是稳定的排序算法吗？
我们可以在数据相同的时候不进行交换，所以冒泡排序是稳定的排序算法。

3. 冒泡排序的时间复杂度是多少？
    + 最好情况：O(n)
    + 最坏情况：O(n²)
    + 平均情况：O(n²)

### 插入排序（Insertion Sort）
我们先来看一个问题，一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。这是一个动态排序的过程，即动态的往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。

所以，在插入排序中，我们将数组中的数据分为两个区间，**已排序区间**和**未排序区间**。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间的数据一直有序。重复这个过程，直到未排序区间中的元素为空，算法结束。

插入排序也包含两种操作，一种是**元素的比较**，一种是**元素的移动**。当我们需要将一个元素a插入到已排序区间时，需要拿a与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点只会，我们还需要将插入点之后的元素顺序往后移一位，这样才能腾出位置给元素a插入。
```go
func insertSort(a []int) []int {
    if len(a) <= 1 {
        return a
    }
    for i:=1;i<n;i++ {
        value :=a[i]
        j := i-1
        for ;j>=0;j-- {
            if value < a[j] {
                // 数据向后移动
                a[j+1] = a[j]
            } else {
                break
            }
        }
        // 插入数据
        a[j+1] = value
    }
}
```
1. 插入排序是原地排序算法吗？
可以看出，这里只涉及到数据的搬移，并不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是一个原地排序算法。
2. 插入排序是稳定的排序算法吗？
对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
3. 插入排序的时间复杂度是多少？
    + 最好情况：O(n)
    + 最坏情况：O(n²)
    + 平均情况：O(n²)

### 选择排序（Selection Sort）
选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。
```go
func selectSort(a []int) []int {
    if len(a) <= 1 {
        return a
    }
    for i:=0;i<len(a);i++ {
        min := 0
        for j:=i+1;j<len(a);j++ {
            if a[j] < a[min] {
                min = j
            }
        }
        a[i],a[min]=a[min],a[i]
    }
    return a
}
```
1. 选择排序是原地排序算法吗？
其空间复杂度为O(1)，是原地排序算法
2. 选择排序是稳定的排序算法吗？
由于每次都要将未排序区间的最小值放到未排序区间的最前面，需要进行数据交换，无法保证数据的先后顺序，所以选择排序不是稳定的排序算法。
3. 选择排序的时间复杂度：
+ 最好情况：O(n)
    + 最好情况：O(n)
    + 最坏情况：O(n²)
    + 平均情况：O(n²)
