+++
title="（二）链表(上)"
date=2020-03-15T14:35:17+08:00
categories=["数据结构与算法"]
+++

### 如何实现LRU缓存淘汰算法？
缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。

缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）

### 五花八门的链表结构
相比数组，链表是一种稍微复杂一点的数据结构。我们先来看，这两者有什么区别。
+ **底层的存储结构**
  + `数组`需要一块**连续的内存空间**来存储，对内存的要求比较高。如果我们申请一个100MB大小的数组，当内存中没有连续的、足够达的存储空间时，即便内存的剩余总可用空间大于100MB，仍然会申请失败
  + `链表`通过“指针”将一组**零散的内存块**串联起来使用，所有如果我们申请的是100MB大小的链表，根本不会有问题

链表的结构五花八门，这里列举三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。我们首先来看最简单、最常用的**单链表**。

1. **单链表**
链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的**结点**。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录在链表上的下一共结点的地址。我们把这个记录下个结点地址的指针叫做**后继指针next**。
<br/>在链表中有两个结点是比较特殊的，它们分别是第一个结点（<b>头结点</b>）和最后一个结点（<b>尾结点</b>）。其中头结点用来记录链表的基地址。有了它，我们就可用遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个**空地址NULL**，表示这是链表上最后一个结点。
<br/>与数组一样，链表也支持数据的查找、插入和删除操作。由于链表本身就不是连续的，所以并不需要数做大量据搬移，所以它删除和插入的时间复杂度都是O(1)。
<br/>有利就有弊，由于链表不是连续的，每个结点都只知道自己后面的是谁，所以当我们希望知道排在第k位的是什么的时候，我们就需要从第一个开始，一个一个往下数。所以链表随机访问性每有数组那么好，需要O(n)的时间复杂度。
<br/>由于Go语言本身只支持双向链表和循环链表，所以我们这里仿照源码实现一下单向链表。
    ```go
    // 结点
    type  Element struct {
        next *Element
        list *List
        Value interface{}
    }
    // 链表
    type List struct {
        root Element
        len int
    }
    func (e *Element) Next() *Element {
        if p := e.next; e.list != nil && p != &e.list.root {
            return p
        }
        return nil
    }
    // 插入
    func (l *List) insert(e,at *Element) *Element {
        e.next = at.next
        at.next = e
        e.list = l
        l.len++
        return e
    }
    // 删除
    func (l *List) remove(e *Element) *Element {
        // 找到前驱结点
        pre := &l.root
        next := pre.next
        for next != nil {
            if pre.next == e {
            pre.next = e.next
            e.next = nil
            e.list = nil
            l.len --
            }
            pre = next
            next = pre.next
        }
        return e
    }
    ```

2. **循环链表**
**循环链表是一种特殊的单链表**。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。它像一个环一样首尾相连，所以叫做“循环”链表。
<br/>和单链表相比，<b>循环链表</b>的优点是从链尾到链头比较方便。当要处理的数据具有环结构特点时，就特别适合采用循环链表。
<br/>在Go语言中，循环链表使用双向链表实现。[双向循环链表-ring](https://golang.google.cn/pkg/container/ring/#Ring)

3. **双向链表**
顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然这样比较浪费存储空间，但可以支持双向遍历，也使得操作更加灵活。
<br/>从结构上来看，双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，使得双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

现在，你有没有觉得双向链表要比单链表更加高效呢？这就是因为在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。实际上，这里有一个更加重要的知识点需要掌握，那就是**用空间换时间**的设计思想。当内存空间充足的时候，如果我们更加追求代码的指向速度，我们就可以选择空间复杂相对教高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或单片机上，这个时候，就要反过来用**时间换空间**的设计思路。

缓存实际上就是利用了空间换时间的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。

所以，对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。

### 链表 VS 数组
|时间复杂度|数组|链表|
|:--:|:--:|:--:|
|插入、删除|O(n)|O(1)|
|随机访问|O(1)|O(n)|
不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。

数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。

### 思考题
如何判断一个字符串是否是回文字符串的问题，应该都听过。那如果字符串是通过单链表来存储的，那该如何判断是一个回文串呢？相应的时间空间复杂度又是多少呢？
**解决思路**：
1. 快慢指针定位中间结点（快结点前进2步，慢结点前进一步）
2. 从中间结点对后半部分逆序
3. 前后半部分比较，判断是否为回文
4. 后半部分逆序复原

时间复杂度O(n)，空间复杂度O(1)。如果使用双向链表，时间效率更高

