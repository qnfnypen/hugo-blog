+++
title="（四）栈"
date=2020-03-17T09:49:11+08:00
categories=["数据结构与算法"]
toc=false
+++

### 浏览器的前进与后退？
当我们依次访问完一串页面a-b-c之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面b和a。反之亦然。但是，如果退到页面b的时候，点击了新的页面d，就无法再通过前进、后退功能查看页面c了。那么这种前进与后退的功能是如何实现的呢。

### 如何理解“栈”
**先进者后出，后进者先出，这就是典型的“栈”结构**。就好比我们叠盘子的时候，都是从下往上一个一个放；取的时候，我们从上往下一个一个的依次取。

从栈的操作特性上来看，**栈是一种“操作受限”的线性表**，只允许在一端插入和删除数据。相比数组和链表，栈有很多限制，从功能上来说，数组和链表确实可以替代栈，但是要知道：**特定的数据结构是对特定场景的抽象**，数组和链表暴露了太多的操作接口，操作上的确灵活自由，但是使用时就比较不可控，很容易出错。

当某个数据集合只涉及在一端插入和删除数据，并且满足先进后出，后进先出的特性，我们就应该首选“栈”这种数据结构。

### 如何实现一个“栈”
从栈的定义中，我们可以看出，栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。

正如前面所言，栈是一种操作受限的线性表结构，所以可以用数组和链表来实现。用数组实现的栈，我们叫做**顺序栈**，用链表实现的栈，我们叫做**链式栈**。
```go
// 顺序栈
type arrayStack struct {
    items []interface  // 数组
    count int   // 栈中的元素个数
    cap int // 栈的大小
}

// 初始化
func newArrayStack(n int) *arrayStack {
    a := &arrayStack{}
    a.items = make([]interface,10,10)
    a.count = 0
    a.cap = n
    return a
}

// 入栈
func (a *arrayStack) push(item interface{}) error {
    // 当空间不够时
    if a.count == a.cap {
        return errors.new("栈空间不足，入栈失败")
    }
    a.items[a.count] = item
    a.count++
    return nil
}

// 出栈
func (a *arrayStack) pop() (interface{},error) {
    // 当栈为空时
    if a.count == 0 {
        return nil,errors.New("栈为空，出栈失败")
    }
    t := a.items[a.count-1]
    a.items[a.count-1] = nil
    a.count--
    return t,nil
}
```
不管是顺序栈还是链式栈，在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是O(1)。注意，我们在说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间，所以这里存储数据需要的大小n的数组，并不能说空间复杂度就是O(n)。

### 支持动态扩容的顺序栈
Go语言的slice本身就是支持动态扩容的，当低于1024的时候，是2倍扩容，当高于1024的时候，扩容因子变为1.25，即每次增加原来的四分之一。需要注意的是，只有使用append函数的时候才会扩容，当使用下标的时候会报错。注意，这里不考虑出栈之后的缩容机制，其实在平常的开发中也很少会有缩容，因为缩容扩容会导致频繁的数据迁移，增加时间复杂度和空间复杂度。

### 栈在函数调用中的应用
操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储调用临时变量。也就是常说的**函数调用栈**。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。为了更好的理解，我们看一下这段代码的执行过程：
```go
func main() {
    a := 1
    ret := 0
    res := 0
    ret = add(3,5)
    res = a + ret
    fmt.Printf("%d",res)
}

func add(x,y int) int {
    sum := 0
    sum = x + y
    return sum
}
```
从代码中，我们看出main()函数调用了add()函数，获取计算结果，并与临时变量a相加，最后打印res值。为了更加清晰的看到这个过程对应的函数里出栈、入栈的操作，这里有一张图，显示的是，在执行到add()函数时，函数调用栈的情况。
![](https://pic.downk.cc/item/5e732188e83c3a1e3a76bc5b.png)

### 栈在表达式求值中的应用
我们再来看栈的另一个常见的应用场景，编译器如何利用栈来实现**表达式求值**。

为了方便解释，这里将表达式简化为四则运算，如：34+13*9+44-12/3。虽然人脑可以很快的给出答案，但是对于计算机而言，理解这个表达式就很难。

实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行优先级比较。

如果运算符栈顶元素的优先级高，就将当前的运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数的栈顶取2个操作数，然后进行计算再把计算完的结果压入操作数栈，继续比较。

这里将3+5*8-6这个表达式的计算过程画成了一张图，可以结合图来理解刚刚说的计算过程。
![](https://pic.downk.cc/item/5e7325f2e83c3a1e3a792e43.png)

### 栈在括号匹配中的应用
除了用栈来实现表达式求值，我们还可以借助栈来检查表达式中的括号是否匹配。

我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如：“(” 和 “)”匹配，“[” 和 “]”匹配，“{” 和 “}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不难匹配的右括号，或者栈中没有数据，则说明为非法格式。

### 解答开篇
我们使用两个栈，X和Y，我们把首次浏览的页面依次压入栈X，当点击后退按钮的时候，再依次从栈X中出栈，并将出栈的数据依次放入栈Y。当我们点击前进按钮时，我们依次从Y中取出数据，放入栈X中。当栈X中没有数据数据时，就说明没有页面可以继续后退浏览了。当栈Y中没有数据，那就说明没有页面可以点击前进按钮浏览了。

当我们通过点击后退按钮回到页面b的时候，通过页面b跳转到新的页面d，这个时候页面c就无法通过前进、后退按钮重复查看，所以需要清空栈Y。