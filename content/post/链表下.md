---
title="（三）链表（下）"
date=2020-03-16T00:25:52+08:00
categories=["数据结构与算法"]
description="如何轻松写出正确的链表代码"
---

想要写好链表代码并不是容易的事情，尤其是那些复杂的链表操作，比如链表反转、有序链表合并等，写的时候非常容易出错。虽然付出精力是成功的先决条件，但任何事物终究有一些技巧可言的。

### 技巧一：理解指针或引用的含义
我们知道，有些语言没有“指针”的概念，取而代之的是“引用”。但不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。

在编写链表代码的时候，我们经常会有这样的代码：
```go
p.next = &q
```
这行代码表示，p结点的后继指针存储了q结点的内存地址。

### 技巧二：警惕指针丢失和内存泄漏
编写链表代码的，指针指来指去，一会就不知道指到哪里了。所以，我们在写链表代码的时候，一定注意不要弄丢了指针。

我们拿单链表插入结点的例子来看：
```go
// 假如我们要在at结点之后插入e结点
e := &element{Value:30}
at.next = e
// 假使我们直接将e结点赋给at的next指针
// 那么at原本的后继结点就会被丢失掉，存在了指针丢失

// 所以我们先把at的后继结点赋给e结点的next指针
e.next = at.next
at.next = e
```
同理，<b>删除链表结点时，也一定要记得手动释放内存空间</b>，否则也会出现内存泄漏的问题。
```go
// 手动释放内存
// 我们删除e结点
e.next = nil
e.list = nil
```
### 技巧三：利用哨兵简化实现难度
首先，我们先来回顾一下单链表的插入和删除操作。如果我们在结点at后面插入一个新的结点e，只需要下面两行代码就可以搞定。
```go
// 插入结点
e.next = at.next
at.next = e

// 删除e的后继结点
e.next = e.next.next
```
但是发现问题了没有。当我们要插入的是第一个结点的时候，或者要删除的是最后一个结点的时候，上面的逻辑就会出错，需要进行特别的处理。

如果我们引入哨兵结点，在任何时候，不管链表是不是空，头指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫**带头链表**。相反，没有哨兵结点的链表就叫做**不带头链表**。

### 技巧四：重点留意边界条件处理
通常来说用来检查链表代码是否正确的边界条件有这样几个：
+ 如果链表为空时，代码是否能正常工作？
+ 如果链表只包含一个结点时，代码是否能正常工作？
+ 如果链表只包含两个结点时，代码是否能正常工作？
+ 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

实际上，不光光是写链表代码，在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，写出的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮。

### 技巧五：举例画图，辅助思考
对于稍微复杂的链表操作，比如前面我们提到的单链表反转，指针一会指这，一会指那，很容易被绕晕。所以这个时候使用**举例法**和**画图法**就可以释放一些脑容量，留更多的给逻辑思考。

比如往单链表插入一个数据这样一个操作，可以把各种情况都举一个例子，画出插入前和插入后的链表变化：
![](https://pic.downk.cc/item/5e71bc73e83c3a1e3ab7e5c5.jpg)
看图写代码，是不是就简单多了。而且，当我们写完代码之后，也可以举几个例子，画在纸上，照着代码走一遍，很容易就能发现代码中的Bug。

### 技巧六：多写多练，没有捷径
这里精选了5个常见的链表操作。只要把这几个操作都能写熟练，不熟就多写几遍，一会就再也不会害怕写链表代码：
+ 单链表反转
+ 链表中环的检测
+ 两个有序链表的合并
+ 删除链表中倒数第n个结点
+ 求链表的中间结点

### 内容小结
**写链表代码是最考验逻辑思维能力的**。因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生Bug。链表代码写的好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。所以一定要自己写代码实现一下，才有效果。