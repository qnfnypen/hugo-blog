+++
title="（七）路由协议"
date=2020-03-19T00:33:19+08:00
categories=["网络协议"]
toc=false
+++

### 如何配置路由？
我们知道路由器就是一台网络设备，它一多张网卡。当一个入口的网络包送到路由器时，她会根据一个本地的转发信息库，来决定如何正确的转发流量。这个转发信息库通常被称为**路由表**。

一张路由表中会有多条路由规则。每一条规则至少包含这三项信息：
  + 目的网络：这个包想去哪儿？
  + 出口设备：将包从哪个口扔出去？
  + 下一跳网关：下一个路由器的地址。

通过route命令和ip route命令都可以进行查询或者配置。例如，我们设置ip route add 10.176.48.0/20 via 10.173.32.1 dev etho，就说明要去10.176.48.0/20这个目标网络，要从eth0端口出去，经过10.173.32.1。这种配置方式的一个核心思想是：**根据目的IP地址来配置路由**。

### 如何配置策略路由？
在真实的复杂的网络环境中，除了可以根据目的ip地址配置路由外，还可以根据多个参数来配置路由，这就称为**策略路由**。可以配置多个路由表，可以根据源IP地址、入口设备、TOS等选择路由表，然后在路由表在查找路由。这样可以使得来自不同来源的包走不同的路由。例如，我们设置：
```shell script
ip rule add from 192.168.1.0/24 table 10
ip rule add from 192.168.2.0/24 table 20
```
表示从192.168.1.0/24这个网段来的，使用table 10中的路由表，而从192.168.2.0/24网段来的，使用table 20中的路由表。在一条路由规则中，也可以走多条路径。例如，在下面的路由规则中：
```shell script
ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2
```
下一跳有两个地方，分别是100.100.100.1和200.200.200.1,权重分别为1比2。

什么情况会用到如此复杂的配置呢？举一个生活中的例子。

家里从运营商那里拉了两根网线。分属于不同的运营商。一个带宽大一些，一个带宽小一些。这个时候我们不用买普通的家用路由器了，得买可以接两个外网的。

家里的网络就是普通的家用网段192.168.1.x/24。家里有两个租户，分别把线连到路由器上。IP地址为192.168.1.101/24和192.168.1.102/24，网关都是192.168.1.1/24，网关在路由器上。由于家里的网段是私有网段，所以出去的包需要NAT成公网的IP地址，因而路由器是一个NAT路由器。

两个运营商都要为这个网关配置一个公网的IP地址。画成图就是这个样子：
![](https://pic.downk.cc/item/5e7607939d7d586a5407daaa.jpg)
根据这个网络拓扑图，可以将路由器配置成这样：
```shell script

$ ip route list table main 
60.190.27.189/30 dev eth3  proto kernel  scope link  src 60.190.27.190
183.134.188.1 dev eth2  proto kernel  scope link  src 183.134.189.34
192.168.1.0/24 dev eth0  proto kernel  scope link  src 192.168.1.1
127.0.0.0/8 dev lo  scope link
default via 183.134.188.1 dev eth2
```
当路由器这样配置的时候，就告诉这个路由器如下规则：
  + 如果去运营商二，就走eth3
  + 如果去运营商一，就走eth2
  + 如果访问内网，就走eth0
  + 如果所有规则都匹配不上，默认走运营商一，也即走快的网络

那如果不想让租户A走快的运营商怎么办呢？我们添加一个table，名字叫chao：
```shell script
echo 200 chao >> /ect/iproute2/rt_tables
```
添加一条规则：
```shell script
# ip rule add from 192.168.1.101 table chao
# ip rule ls
0:  from all lookup local 
32765:  from 192.168.1.101 lookup chao
32766:  from all lookup main 
32767:  from all lookup default
```
设定规则为：从192.168.1.101来的包都查看chao这个新的路由表。在chao路由表中添加规则：
```shell script

# ip route add default via 60.190.27.189 dev eth3 table chao
# ip route flush cache
```
默认走最慢的。

上面所说的都是静态路由，一般来说网络环境简单的时候，在自己的可控范围之内，自己鼓捣还是可以的。但是有时候网络环境复杂并且多变，如果总是用静态路由，一旦网络结构发生变化，让网络管理员手动修改路由太复杂了，因而需要动态路由算法。

### 动态路由算法
使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状态的变化而变化。那路由算法是什么样的呢？

包无论是在内网中传递还是在外网中传递，肯定想传递的路越少越好，因而这就转换成**如何在途中找到最短路径**的问题。

在学习数据结构的时候，知道求最短路径常用的有两种算法：Bellman-Ford算法和Dijkstra算法。在计算机网络中基本也是用这两种方法计算的。
  1. **距离矢量路由（distance vector routing）算法**
  它是基于Bellman-Ford算法的。这种算法的基本思路是，每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每一行包含两部分信息，一个是要到目标路由器，从哪条线出去，另一个是到目标路由器的距离。
  <br/>每个路由器都通过临近的路由器知道其知道的信息，从而知道全局的信息。每个路由器根据新收集的信息，计算和其他路由器的距离，比如自己的一个邻居距离自己目标路由的距离是M，自己距离邻居是x，则自己距离目标路由器是x+M。
  <br/>这个算法比较简单，但是还是有问题：
     + **好消息传得很快，坏消息传得很慢**，当有新路由加入网络后，很快就会被临近路由器发现，然后将消息广播出去。但是当一个路由器挂了，是没有广播消息的，要所有路径都试一下，或者超过阈值才能判断它是真的挂了。
     + **每次发送的时候，要发送整个全局路由表**，当网络大了，包的大小就大了，所有最早的路由协议RIP就是基于这个算法，它适用于小型网络。

     <br/>所以这两个问题，限制了距离矢量路由的网络规模。

  2. **链路状态路由（link state routing）算法**
  它是基于Dijkstra算法的。这个算法的基本思路是：
     1. 当一个路由器启动的时候，首先是发现邻居，向邻居say hello，邻居都回复
     2. 计算和邻居的距离，发送一个echo，要求马上返回，除以二就是距离
     3. 将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器，这样每个路由器都能够收到它和邻居之间的关系信息
     4. 每个路由器都在自己本地构建一个完整的图，然后针对这个图使用Dijkstra算法，找到两点之间的最短路径。

     <br/>不像距离矢量路由协议那样，更新时发送整个路由表。链路状态路由吸引只广播新的或改变的网络拓扑，这使得更新信息更小，节省了带宽和CPU利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。

### 动态路由协议
1. **基于链路状态路由算法的OSPF**
   <b>OSPF（Open Shortest Path First，开放式最短路径优先）</b>广泛应用在数据中心的协议。由于主要在数据中心内部，用于路由决策，因而称为<b>内部网关协议（Interior Gateway Protocaol，简称IGP）</b>

   <br/>内部网关协议的重点就是找到最短的路径。在一个组织内部，路径最短往往最优。当然有时候OSPF可以发现多个最短路径，可以在这多个路径中进行负载均衡，这常常被称为**等价路由**。

   <br/>有了等价路由，到一个地方去可以有相同的多个路线，这样可以分摊流量，还可以当一条路不通的时候，走其他路。

2. **基于距离矢量路由算法的BGP**
  但是外网的路由协议，又有所不同。我们称为**外网路由协议（Border Gateway Protocol，简称BGP）**。
  <br/>在内网在，当然可以选近的路走。但是在外网中，不光要考虑远近的问题，还应该考虑政策的问题。
  <br/>对于网络包来说，每个数据中心都设置自己的Policy。例如，哪些外部的IP可以让内部知晓，哪些内部的IP可以让外部知晓，哪些可以通过，哪些不能通过。这就好比，虽然从我家里到目的地最近，但是不能随都从我家走啊！
  <br/>在网络世界在，这一个个数据中心成为自治系统**AS**（Autonomous System）。自治系统分为这几种类型：
    + Stub As：对外只有一个连接。这类AS不会传输其他AS的包。例如，个人或小公司的网络
    + Multihomed AS：可能有多个连接到其他的AS，但是大多拒绝帮其他的AS传输包。例如一些大公司的网络
    + Transit AS：有多个连接到其他的AS，并且可以帮助其他的AS传输包。例如主干网
  
    <br/>每个自治系统都有边界路由器，通过它和外面的世界建立联系。

    <br/>**BGP又分为两类，eBGP和iBGP**。自治系统间，边界路由器之间使用eBGP广播路由。内部网络也需要访问其他的自治系统。边界路由器如何将BGP学习到的路由导入到内部网络呢？就是通过运行iBGP，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。

    <br/>前面说了距离矢量路由算法的缺点。其中一个是收敛慢。在BGP里面，除了下一跳hop之外，还包括了自治系统AS的路径，从而可以避免坏消息传的慢的问题。另外，在路径中将一个自治系统看成一个整体，不区分自治系统内部的路由器，这样自治系统的数目是非常有限的。就像从中国先出发到韩国再到日本，只要不细到具体那一站，就算是发送全局信息，也是没有问题的。

  
  



